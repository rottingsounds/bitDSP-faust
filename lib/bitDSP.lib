declare name "bitDSP";
declare author "LFSaw (Till Bovermann), Dario Sanfilippo";
declare copyright "MIT";

// bin = library("bitDSP"); // main library
// bin32 = library("bitDSP_int32"); // int32-based library
// binBus = library("bitDSP_binBus"); // int32-based library
// binConv = library("bitDSP_conversion"); // conversion between formats library

// sc = library("scUGens.lib"); // part of https://github.com/tai-studio/faust-sc
// lf = library("taiStudio.lib"); // part of https://github.com/tai-studio/faust-sc

// import("stdfaust.lib");
// only import what is necessary
// 
// an = library("analyzers.lib");
ba = library("basics.lib");
// co = library("compressors.lib");
de = library("delays.lib");
// dm = library("demos.lib");
// dx = library("dx7.lib");
// en = library("envelopes.lib");
fi = library("filters.lib");
// ho = library("hoa.lib");
// it = library("interpolators.lib");
ma = library("maths.lib");
// mi = library("mi.lib");
// ef = library("misceffects.lib");
// os = library("oscillators.lib");
// no = library("noises.lib");
// pf = library("phaflangers.lib");
// pl = library("platform.lib");
// pm = library("physmodels.lib");
// rm = library("reducemaps.lib");
// re = library("reverbs.lib");
// ro = library("routes.lib");
// sp = library("spats.lib");
si = library("signals.lib");
// so = library("soundfiles.lib");
// sy = library("synths.lib");
// ve = library("vaeffects.lib");
// wa = library("webaudio.lib");
// sf = library("all.lib");
// vl = library("version.lib");




/////////////////////////// oscillators

// bool_osc0(del1[n], del2[n], del3[n], del4[n]); ------------------------------
//
// (author: Dario Sanfilippo)
//
// Basic Boolean oscillator with four cross-coupled nodes, mainly for
// chaotic oscillations including limit cycles and strange attractors.
//
// The future development of this approach could be to have a set of
// nodes with specific Boolean processes that can be combined in
// networks of arbitrary sizes and topology by simple argument
// specification.
//
// 4 inputs:
//    del1[n], delay of the output of the first node up to SR samples;
//    del2[n], delay of the output of the second node up to SR samples;
//    del3[n], delay of the output of the third node up to SR samples;
//    del4[n], delay of the output of the fourth node up to SR samples;
//
// 1 outputs:
//    y[n], first node;
//
bool_osc0(del1, del2, del3, del4) = node1         
      letrec {
           'node1 = not(node1 & node2) @ max(0, min(ma.SR, del1));
           'node2 = not(node2 | node3) @ max(0, min(ma.SR, del2));
           'node3 = not(node3 xor node4) @ max(0, min(ma.SR, del3));
           'node4 = not(node4 & node1) @ max(0, min(ma.SR, del4));
      }
      with {
           not(x) = rint(1 - x);
      };
// -----------------------------------------------------------------------------

// bool_osc1(del1[n], del2[n]); ------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Basic Boolean oscillator with two cross-coupled nodes, mainly for 
// chaotic oscillations including limit cycles and strange attractors.
//
// The future development of this approach could be to have a set of
// nodes with specific Boolean processes that can be combined in
// networks of arbitrary sizes and topology by simple argument
// specification.
//
// 2 inputs:
//    del1[n], delay of the output of the first node up to SR samples;
//    del2[n], delay of the output of the second node up to SR samples;
//
// 1 outputs:
//    y[n], first node;
//
bool_osc1(del1, del2) = node1
      letrec {
           'node1 = not(node1 xor node2 & node1) @ max(0, min(ma.SR, del1));
           'node2 = not(node2 xor node1 xor node2) @ max(0, min(ma.SR, del2));
      } 
      with {
           not(x) = 1 - x;
      };
// -----------------------------------------------------------------------------

// bool_osc2(del1[n], del2[n]); ------------------------------------------------
//
// (author: Dario Sanfilippo)
//
// Basic Boolean oscillator with two cross-coupled nodes, mainly for
// chaotic oscillations including limit cycles and strange attractors.
//
// The future development of this approach could be to have a set of
// nodes with specific Boolean processes that can be combined in
// networks of arbitrary sizes and topology by simple argument
// specification.
//
// 2 inputs:
//    del1[n], delay of the output of the first node up to SR samples;
//    del2[n], delay of the output of the second node up to SR samples;
//
// 1 outputs:
//    y[n], first node;
//
bool_osc2(del1, del2) = node1
                           
      letrec {
           'node1 = not(node1 & node2) @ max(0, min(ma.SR, del1));
           'node2 = not(node1 & node2) @ max(0, min(ma.SR, del2));
      }
      with {
           not(x) = rint(1 - x);
      };
// -----------------------------------------------------------------------------

// cic(N, CF[n], x[n]); --------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Comb-integrator circuit lowpass filter.
// Based on Eric Lyon's: https://www.dsprelated.com/showarticle/1337.php.
//
// 2 inputs:
//    CF[n], cut-off frequency in Hz;
//    x[n].
//
// 1 outputs:
//    y[n], lowpassed x[n].
//
// 1 compile-time arguments: 
//    "N", (integer) order of the filter.
//
cic(N, cf, x) = x : seq(i, N, delta(1, .5 / cf) :
    fi.pole(1)) / (.5 / cf * ma.SR) ^ N;
// -----------------------------------------------------------------------------


// delta(S, dt[n], x[n]); ------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// First derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
// 1 compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta(s, t, in) =  in - de.fdelay(size * ma.SR, del * ma.SR, in);
// -----------------------------------------------------------------------------

// dsm1(x[n]); -----------------------------------------------------------------
//
// (author: Till Bovermann) 
//
// First-order digital delta-sigma modulator.
//
// 1 inputs:
//    x[n];
//
// 1 outputs:
//    y[n], modulated input in the range [-1; 1].
//
dsm1(x) = loop
         ~ _
      with {
        loop(fb) = x - fb : posFB > 0 : select2(_, -1, 1);
        posFB(fb) = (_, fb : +) ~ _;
      };
// -----------------------------------------------------------------------------


// dsm2(x[n]); -----------------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Second-order digital delta-sigma modulator.
//
// 1 inputs:
//    x[n];
//
// 1 outputs:
//    y[n], modulated input in the range [-1; 1].
//
dsm2(x) =  loop
           ~ _
      with {
           loop(fb) = x - fb : fi.pole(1) - 2 * fb : fi.pole(1) : Q;
           Q(z) = select2(z < 0, 1, -1);
      };
// -----------------------------------------------------------------------------

// full_adder(x1[n], x2[n], c_in[n]); ------------------------------------------
//
// (author: Dario Sanfilippo)
//
// Adder for binary values. It adds two operands as well as a carrier
// input. It outputs the sum as well as the carrier output.
//
// 3 inputs:
//    x1[n], first operand;
//    x2[n], second operand;
//    c_in[n], carrier input.
//
// 2 outputs:
//    s_out[n], resulting sum;
//    c_out[n], carrier output.
//
full_adder(x1, x2, c_in) = s_out , 
                           c_out
      with {
           s_out = xor(c_in, xor(x1, x2));
           c_out = (c_in & xor(x1, x2)) | (x1 & x2);
      };
// -----------------------------------------------------------------------------

// bitstream_adder(x1[n], x2[n]); ----------------------------------------------
//
// (author: Dario Sanfilippo)
//
// Adder for delta-sigma-modulated streams.
//
// 2 inputs:
//    x1[n], first bitstream;
//    x2[n], second bitstream.
//
// 1 outputs:
//    y[n], resulting bitstream summation.
//
bitstream_adder(x1, x2) =  loop
                           ~ _ : ( ! , 
                                   _)
      with {
           loop(fb) = full_adder(x1, x2, fb);
      };
// -----------------------------------------------------------------------------

////////////////////// utilities

