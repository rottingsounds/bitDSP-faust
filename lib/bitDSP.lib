declare name "bitDSP";
declare author "LFSaw & Dario Sanfilippo";
declare copyright "MIT";

int_min = fconstant(int INT_MIN, <climits>);
int_max = fconstant(int INT_MAX, <climits>);

//---------------------------------`(b.)bitNot`---------------------------------------
// bitwise Not
//
// #### Usage
//
// ```
// 16: bitNot
// ```
//-----------------------------------------------------------------------------
bitNot = ffunction(int bit_not (int), "bitDSP.h", "");


//---------------------------------`(b.)div`---------------------------------------
// integer division
//
// #### Usage
//
// ```
// 31, 32: div
// div(31, 32)
// ```
//-----------------------------------------------------------------------------
div = ffunction(int div_i (int, int), "bitDSP.h", "");


//---------------------------------`(b.)delay32`---------------------------------------
// single-bit delay on an integer bitstream. maximum of 32bit delays possible.
//
// #### Usage
//
// ```
// delay32(delta, _)
// ```
//-----------------------------------------------------------------------------
delay32(0, x) = x;
delay32(delta, x) = ((x >> delta) | (x' << (32-delta)));


//---------------------------------`(b.)delay`---------------------------------------
// single-bit delay on integer bitstream
//
// #### Usage
//
// ```
// delay(delta, _)
// ```
//-----------------------------------------------------------------------------
delay(delta, x) = delay32((delta % 32), x@( (delta, 32) : div ));



//---------------------------------`(b.)print`---------------------------------------
// print an integer as a bit representation
//
// #### Usage
//
// ```
// print(_)
// ```
//-----------------------------------------------------------------------------
print = ffunction(int bit_print (int), "bitDSP.h", "");



//---------------------------------`(b.)print2`---------------------------------------
// print an integer as a bit representation, including two slots for (integer) counters. 
// useful to output sample and channel count. 
//
// #### Usage
//
// ```
// print(_)
// ```
//-----------------------------------------------------------------------------
print2 = ffunction(int bit_print2counters (int, int, int), "bitDSP.h", "");



//---------------------------------`(b.)int2binary`---------------------------------------
// (original by dario (dec2bin), copied from the faust slack channel)
// 
//
// #### Usage
//
// ```
// int2binary(_)
// ```
//-----------------------------------------------------------------------------
int2binary(0) = 0:!;
int2binary(N) = int2binary(div(N,2)) , N % 2;



//---------------------------------`(b.)bitDAC_i`---------------------------------------
// select bits of an integer to be interpreted as PCM values
// range is [0, 1, .. (2^size)[
//
// #### Usage
//
// ```
// bitDAC_i(8, 2, _)
// ```
//-----------------------------------------------------------------------------
bitDAC_i(size, offset, in) = (in & bitmask) >> offset // shift selection to right-most bits
with {
	maxval = (1 << size)-1; // maximum value that fits into size
	bitmask = maxval << offset; // mask selects area of which to create PCM values
};


//---------------------------------`(b.)bitDAC`---------------------------------------
// select bits of an integer to be interpreted as PCM values
// range is [0.f .. 1]
//
// #### Usage
//
// ```
// bitDAC(8, 2, _)
// ```
// 
// #### Example: 6-bit noise
// 
// ```
// bitDAC(6, 0, int(no.noise * 10));
// ```
//-----------------------------------------------------------------------------
bitDAC(offset, size, in) = normed((in & bitmask) >> offset) // shift selection to right-most bits
with {
	maxval = (1 << size)-1; // maximum value that fits into size
	bitmask = maxval << offset; // mask selects area in which to create PCM values
	normed(out) = out / (maxval-1); // normalise values to be between 0 and 1 (excl.)
};




//---------------------------------`(b.)maskedNot`---------------------------------------
// invert selected bits of an integer
//
// #### Usage
//
// ```
// maskedNot(mask, in)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
// maskedNot(mask, in) = (mask & bitNot(in)) | (bitNot(mask) & in);
maskedNot(mask, in) = applyMask(bitNot(in), a, mask);


//---------------------------------`(b.)maskedAnd`---------------------------------------
// bit-wise AND of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedAnd(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedAnd(mask, a, b) = applyMask(a&b, a, mask);


//---------------------------------`(b.)maskedOr`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedOr(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedOr(mask, a, b) = applyMask(a|b, a, mask);


//---------------------------------`(b.)maskedXor`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedXor(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedXor(mask, a, b) = applyMask(xor(a,b), a, mask);


//---------------------------------`(b.)applyMask`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// applyMask(res, org, mask)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
applyMask(res, org, mask) = (mask & res) | (bitNot(mask) & orig);

//==============================================================================
//==============================================================================
//    Begin of Dario's section     =============================================
//==============================================================================
//==============================================================================

// cic(N, CF[n], x[n]); --------------------------------------------------------
//
// Comb-integrator circuit lowpass filter.
// Based on Eric Lyon's: https://www.dsprelated.com/showarticle/1337.php.
//
// 2 inputs:
//    CF[n], cut-off frequency in Hz;
//    x[n].
//
// 1 outputs:
//    y[n], lowpassed x[n].
//
// 1 compile-time arguments: 
//    "N", (integer) order of the filter.
//
cic(N, cf, x) = x : seq(i, N, delta(1, .5 / cf) :
    fi.pole(1)) / (.5 / cf * ma.SR) ^ N;
// -----------------------------------------------------------------------------

// dec2bin(N); -----------------------------------------------------------------
//
// It converts a decimal integer (N) into a Faust list containing the binary
// digits, that is, the binary digits in parallel.
//
// 0 inputs.
//
// M = ceil(ma.log2(N)) outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yM[n], binary digits representing N.
//
// 1 compile-time arguments:
//    N, decimal integer number.
//
dec2bin(0) = 0:!;
dec2bin(N) =   dec2bin(int(N / 2)) ,
               N % 2;
// -----------------------------------------------------------------------------

// delta(S, dt[n], x[n]); ------------------------------------------------------
//
// First derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
// 1 compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta(s, t, in) =  in - de.fdelay(size * ma.SR, del * ma.SR, in);
// -----------------------------------------------------------------------------

// eca(L, R, I, rate[n]); ------------------------------------------------------
//
// One-dimension, two-state, elementary cellular automata with circular
// lattice. The function is defined by the length of the lattice, a rule, and
// an initial condition. Additionally, the function has a "rate" parameter
// that determines the interval between iterations. The rule and the initial
// condition are positive INTs that are converted into binary numbers and
// accordingly zero-padded or limited to reach a binary string of
// appropriate length.
//
// Ref:
//    Wolfram, S. (1984). Cellular automata as models of complexity. Nature,
//    311(5985), 419-424.
//
//    Wolfram, S. (2018). Cellular automata and complexity: collected papers.
//    CRC Press.
//
// 1 inputs:
//    rate[n], iteration rate.
//
// L outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yL[n], states of the cells in the lattice.
//
// 3 compile-time arguments:
//    L, (positive INT) size of the lattice (number of cells);
//    R, (positive INT up to 255) rule applied to the 8 possible cases;
//    I, (positive INT) initial condition for the cells.
//
// Sample-and-hold circuits are deployed to have arbitrary iteration
// rates.
eca(L, R, I, rate) =   (   si.bus(L) ,
                           init(I) : ro.interleave(L, 2) : par(i, L, +) :
      iterate : par(i, L, ba.sAndH(trigger)))
                       ~ si.bus(L)
      with {
           // The trigger function needs further testing for extremely
           // low iteration rates.
           trigger = ba.period(ma.SR / max(ma.EPSILON, rate)) == 0;
           // Integer wrap-around function assuming a range between 0 and any
           // positive int value M.
           wrap(M, N) = int(ma.frac(N / M) * M);
           // "Wolfram Number" â€“ an int between 0 and 255 representing
           // all 256 possible outcomes for the eight cases (see below).
           // Eight total cases and two possible outcomes for each case,
           // hence 2^8 rules. Rule 30 and 110 are well-known.
           w_num = zeropad_up(int(8 - ceil(ma.log2(R1))), dec2bin(R1))
               with {
                   R1 = min(255, R);
               };
           // Initial value for the cells, also expressed as an int. If
           // the binary value of the init is larger than the lattice,
           // the value is clipped. If smaller, 0s are added at the top
           // until the binary string matches the lattice length.
           init(N) = zeropad_up(int(L - ceil(ma.log2(N1))), dec2bin(N1)) :
               par(i, L, _ <: _ - mem)
               with {
                   N1 = min(N, 2 ^ L - 1);
               };
           // Rule application through nested IFs. The rule changes the
           // state of a cell according to the state of its neighbouring
           // cells. Note that this is a circular latice, hence the
           // state of the first cell is determined by the second one and
           // the last one.
           rule(x1, x2, x3) =
      ba.if(   c1, w_num : route(8, 1, 1, 1),
           ba.if(  c2, w_num : route(8, 1, 2, 1),
               ba.if(  c3, w_num : route(8, 1, 3, 1),
                   ba.if(  c4, w_num : route(8, 1, 4, 1),
                       ba.if(  c5, w_num : route(8, 1, 5, 1),
                           ba.if(  c6, w_num : route(8, 1, 6, 1),
                               ba.if(  c7, w_num : route(8, 1, 7, 1),
                                   w_num : route(8, 1, 8, 1))))))))
               // Two states for three cells, hence 2^3 conditions.
               // Note that the last one is implicit and not used in
               // the IFs above, although it is informative having it
               // here.
               with {
                   c1 = (x1 == 1) & (x2 == 1) & (x3 == 1);
                   c2 = (x1 == 1) & (x2 == 1) & (x3 == 0);
                   c3 = (x1 == 1) & (x2 == 0) & (x3 == 1);
                   c4 = (x1 == 1) & (x2 == 0) & (x3 == 0);
                   c5 = (x1 == 0) & (x2 == 1) & (x3 == 1);
                   c6 = (x1 == 0) & (x2 == 1) & (x3 == 0);
                   c7 = (x1 == 0) & (x2 == 0) & (x3 == 1);
                   c8 = (x1 == 0) & (x2 == 0) & (x3 == 0);
               };
           iterate = si.bus(L) <:
               par(i, L, route(L, 3,   wrap(L, i - 1) + 1, 1,
                                       i + 1, 2,
                                       wrap(L, i + 1) + 1, 3) : int(rule));
      };
// -----------------------------------------------------------------------------

// zeropad_up(N, list); --------------------------------------------------------
//
// This function adds N zeros at the beginning of a list.
//
// 0 inputs.
//
// N+ba.count(list) outputs.
//
// 1 compile-time arguments:
//    N, number of zeros to be added.
//
zeropad_up(0, x) = x;
zeropad_up(N, x) = par(i, N, 0) , x;
// -----------------------------------------------------------------------------
