declare name "bitDSP";
declare author "LFSaw (Till Bovermann), Dario Sanfilippo";
declare copyright "MIT";

// bin = library("bitDSP"); // main library
// bin32 = library("bitDSP_int32"); // int32-based library
// binBus = library("bitDSP_binBus"); // int32-based library
// binConv = library("bitDSP_conversion"); // conversion between formats library

// sc = library("scUGens.lib"); // part of https://github.com/tai-studio/faust-sc
// lf = library("taiStudio.lib"); // part of https://github.com/tai-studio/faust-sc

// import("stdfaust.lib");
// only import what is necessary
// 
// an = library("analyzers.lib");
ba = library("basics.lib");
// co = library("compressors.lib");
de = library("delays.lib");
// dm = library("demos.lib");
// dx = library("dx7.lib");
// en = library("envelopes.lib");
fi = library("filters.lib");
// ho = library("hoa.lib");
// it = library("interpolators.lib");
ma = library("maths.lib");
// mi = library("mi.lib");
// ef = library("misceffects.lib");
// os = library("oscillators.lib");
// no = library("noises.lib");
// pf = library("phaflangers.lib");
// pl = library("platform.lib");
// pm = library("physmodels.lib");
// rm = library("reducemaps.lib");
// re = library("reverbs.lib");
// ro = library("routes.lib");
// sp = library("spats.lib");
si = library("signals.lib");
// so = library("soundfiles.lib");
// sy = library("synths.lib");
// ve = library("vaeffects.lib");
// wa = library("webaudio.lib");
// sf = library("all.lib");
// vl = library("version.lib");




/////////////////////////// oscillators

// bool_osc1(del1[n], del2[n]); ------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Basic Boolean oscillator with two cross-coupled nodes, mainly for 
// chaotic oscillations including limit cycles and strange attractors.
//
// The future development of this approach could be to have a set of
// nodes with specific Boolean processes that can be combined in
// networks of arbitrary sizes and topology by simple argument
// specification.
//
// 2 inputs:
//    del1[n], delay of the output of the first node (1 sec max);
//    del2[n], delay of the output of the second node (1 sec max);
//
// 2 outputs:
//    y1[n], first node;
//    y2[n], second node.
//
bool_osc1(del1, del2) =    node1 ,
                           node2
      letrec {
           'node1 = not(node1 xor node2 & node1) @ max(0, min(ma.SR, del1));
           'node2 = not(node2 xor node1 xor node2) @ max(0, min(ma.SR, del2));
      } 
      with {
           not(x) = 1 - x;
      };
// -----------------------------------------------------------------------------

// cic(N, CF[n], x[n]); --------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Comb-integrator circuit lowpass filter.
// Based on Eric Lyon's: https://www.dsprelated.com/showarticle/1337.php.
//
// 2 inputs:
//    CF[n], cut-off frequency in Hz;
//    x[n].
//
// 1 outputs:
//    y[n], lowpassed x[n].
//
// 1 compile-time arguments: 
//    "N", (integer) order of the filter.
//
cic(N, cf, x) = x : seq(i, N, delta(1, .5 / cf) :
    fi.pole(1)) / (.5 / cf * ma.SR) ^ N;
// -----------------------------------------------------------------------------


// delta(S, dt[n], x[n]); ------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// First derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
// 1 compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta(s, t, in) =  in - de.fdelay(size * ma.SR, del * ma.SR, in);
// -----------------------------------------------------------------------------


// dsm1(x[n]); -----------------------------------------------------------------
//
// (author: Till Bovermann) 
//
// First-order digital delta-sigma modulator.
//
// 1 inputs:
//    x[n];
//
// 1 outputs:
//    y[n], modulated input in the range [-1; 1].
//
dsm1(x) = loop
         ~ _
      with {
        loop(fb) = x - fb : posFB > 0 : select2(_, -1, 1);
        posFB(fb) = (_, fb : +) ~ _;
      };
// -----------------------------------------------------------------------------


// dsm2(x[n]); -----------------------------------------------------------------
//
// (author: Dario Sanfilippo) 
//
// Second-order digital delta-sigma modulator.
//
// 1 inputs:
//    x[n];
//
// 1 outputs:
//    y[n], modulated input in the range [-1; 1].
//
dsm2(x) =  loop
           ~ _
      with {
           loop(fb) = x - fb : fi.pole(1) - 2 * fb : fi.pole(1) : Q;
           Q(z) = select2(z < 0, 1, -1);
      };
// -----------------------------------------------------------------------------

////////////////////// utilities

