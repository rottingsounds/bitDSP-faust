declare name "bitDSP";
declare author "LFSaw";
declare copyright "MIT";

int_min = fconstant(int INT_MIN, <climits>);
int_max = fconstant(int INT_MAX, <climits>);

//---------------------------------`(b.)bitNot`---------------------------------------
// bitwise Not
//
// #### Usage
//
// ```
// 16: bitNot
// ```
//-----------------------------------------------------------------------------
bitNot = ffunction(int bit_not (int), "bitDSP.h", "");


//---------------------------------`(b.)div`---------------------------------------
// integer division
//
// #### Usage
//
// ```
// 31, 32: div
// div(31, 32)
// ```
//-----------------------------------------------------------------------------
div = ffunction(int div_i (int, int), "bitDSP.h", "");


//---------------------------------`(b.)delay32`---------------------------------------
// single-bit delay on an integer bitstream. maximum of 32bit delays possible.
//
// #### Usage
//
// ```
// delay32(delta, _)
// ```
//-----------------------------------------------------------------------------
delay32(0, x) = x;
delay32(delta, x) = ((x >> delta) | (x' << (32-delta)));


//---------------------------------`(b.)delay`---------------------------------------
// single-bit delay on integer bitstream
//
// #### Usage
//
// ```
// delay(delta, _)
// ```
//-----------------------------------------------------------------------------
delay(delta, x) = delay32((delta % 32), x@( (delta, 32) : div ));



//---------------------------------`(b.)print`---------------------------------------
// print an integer as a bit representation
//
// #### Usage
//
// ```
// print(_)
// ```
//-----------------------------------------------------------------------------
print = ffunction(int bit_print (int), "bitDSP.h", "");



//---------------------------------`(b.)print2`---------------------------------------
// print an integer as a bit representation, including two slots for (integer) counters. 
// useful to output sample and channel count. 
//
// #### Usage
//
// ```
// print(_)
// ```
//-----------------------------------------------------------------------------
print2 = ffunction(int bit_print2counters (int, int, int), "bitDSP.h", "");



//---------------------------------`(b.)int2binary`---------------------------------------
// (original by dario (dec2bin), copied from the faust slack channel)
// 
//
// #### Usage
//
// ```
// int2binary(_)
// ```
//-----------------------------------------------------------------------------
int2binary(0) = 0:!;
int2binary(N) = int2binary(div(N,2)) , N % 2;



//---------------------------------`(b.)bitDAC_i`---------------------------------------
// select bits of an integer to be interpreted as PCM values
// range is [0, 1, .. (2^size)[
//
// #### Usage
//
// ```
// bitDAC_i(8, 2, _)
// ```
//-----------------------------------------------------------------------------
bitDAC_i(size, offset, in) = (in & bitmask) >> offset // shift selection to right-most bits
with {
	maxval = (1 << size)-1; // maximum value that fits into size
	bitmask = maxval << offset; // mask selects area of which to create PCM values
};


//---------------------------------`(b.)bitDAC`---------------------------------------
// select bits of an integer to be interpreted as PCM values
// range is [0.f .. 1]
//
// #### Usage
//
// ```
// bitDAC(8, 2, _)
// ```
// 
// #### Example: 6-bit noise
// 
// ```
// bitDAC(6, 0, int(no.noise * 10));
// ```
//-----------------------------------------------------------------------------
bitDAC(offset, size, in) = normed((in & bitmask) >> offset) // shift selection to right-most bits
with {
	maxval = (1 << size)-1; // maximum value that fits into size
	bitmask = maxval << offset; // mask selects area in which to create PCM values
	normed(out) = out / (maxval-1); // normalise values to be between 0 and 1 (excl.)
};




//---------------------------------`(b.)maskedNot`---------------------------------------
// invert selected bits of an integer
//
// #### Usage
//
// ```
// maskedNot(mask, in)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
// maskedNot(mask, in) = (mask & bitNot(in)) | (bitNot(mask) & in);
maskedNot(mask, in) = applyMask(bitNot(in), a, mask);


//---------------------------------`(b.)maskedAnd`---------------------------------------
// bit-wise AND of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedAnd(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedAnd(mask, a, b) = applyMask(a&b, a, mask);


//---------------------------------`(b.)maskedOr`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedOr(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedOr(mask, a, b) = applyMask(a|b, a, mask);


//---------------------------------`(b.)maskedXor`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// maskedXor(mask, a, b)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
maskedXor(mask, a, b) = applyMask(xor(a,b), a, mask);


//---------------------------------`(b.)applyMask`---------------------------------------
// bit-wise OR of selected bits of two integers. remaining bits are kept from first parameter
//
// #### Usage
//
// ```
// applyMask(res, org, mask)
// ```
// TODO: wait for bitNOT implementation
//-----------------------------------------------------------------------------
applyMask(res, org, mask) = (mask & res) | (bitNot(mask) & orig);